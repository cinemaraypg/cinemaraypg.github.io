{"version":3,"file":"webXRSessionManager.js","sourceRoot":"","sources":["../../../../sourceES6/core/Cameras/XR/webXRSessionManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { IDisposable, Scene } from \"../../scene\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { WebXRRenderTarget, WebXRState } from './webXRTypes';\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from './webXRManagedOutputCanvas';\r\n\r\ninterface IRenderTargetProvider {\r\n    getRenderTargetForEye(eye: XREye): RenderTargetTexture;\r\n}\r\n\r\nclass RenderTargetProvider implements IRenderTargetProvider {\r\n    private _texture: RenderTargetTexture;\r\n\r\n    public constructor(texture: RenderTargetTexture) {\r\n        this._texture = texture;\r\n    }\r\n\r\n    public getRenderTargetForEye(eye: XREye): RenderTargetTexture {\r\n        return this._texture;\r\n    }\r\n}\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/how_to/webxr\r\n */\r\nexport class WebXRSessionManager implements IDisposable {\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n\r\n    /**\r\n     * Type of reference space used when creating the session\r\n     */\r\n    public referenceSpace: XRReferenceSpace;\r\n\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n\r\n    private _xrNavigator: any;\r\n    private baseLayer: Nullable<XRWebGLLayer> = null;\r\n    private _rttProvider: Nullable<IRenderTargetProvider>;\r\n\r\n    private _sessionEnded: boolean = false;\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(private scene: Scene) {\r\n\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        Logger.Warn(\"The WebXR APIs are still under development and are subject to change in the future.\");\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"webXR not supported by this browser\");\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param optionalFeatures defines optional values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public initializeSessionAsync(xrSessionMode: XRSessionMode, optionalFeatures: any = {}): Promise<XRSession> {\r\n        return this._xrNavigator.xr.requestSession(xrSessionMode, optionalFeatures).then((session: XRSession) => {\r\n            this.session = session;\r\n            this._sessionEnded = false;\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this.session.addEventListener(\"end\", () => {\r\n                this._sessionEnded = true;\r\n                // Remove render target texture and notify frame obervers\r\n                this._rttProvider = null;\r\n\r\n                // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                this.scene.getEngine().restoreDefaultFramebuffer();\r\n\r\n                // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                this.scene.getEngine().customAnimationFrameRequester = null;\r\n                this.onXRSessionEnded.notifyObservers(null);\r\n                this.scene.getEngine()._renderLoop();\r\n            }, { once: true });\r\n            return this.session;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpace space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public setReferenceSpaceAsync(referenceSpace: XRReferenceSpaceType) {\r\n        return this.session.requestReferenceSpace(referenceSpace).then((referenceSpace: XRReferenceSpace) => {\r\n            this.referenceSpace = referenceSpace;\r\n        }, (rejectionReason) => {\r\n            Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n            Logger.Error(rejectionReason);\r\n            Logger.Log(\"Defaulting to universally-supported \\\"viewer\\\" reference space type.\");\r\n\r\n            return this.session.requestReferenceSpace(\"viewer\").then((referenceSpace: XRReferenceSpace) => {\r\n                this.referenceSpace = referenceSpace;\r\n            }, (rejectionReason) => {\r\n                Logger.Error(rejectionReason);\r\n                throw \"XR initialization failed: required \\\"viewer\\\" reference space type not supported.\";\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     */\r\n    public updateRenderStateAsync(state: XRRenderState) {\r\n        if (state.baseLayer) {\r\n            this.baseLayer = state.baseLayer;\r\n        }\r\n        return this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     * @returns a promise that will resolve once rendering has started\r\n     */\r\n    public startRenderingToXRAsync() {\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        this.scene.getEngine().customAnimationFrameRequester = {\r\n            requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (this._sessionEnded) {\r\n                    return;\r\n                }\r\n                // Store the XR frame in the manager to be consumed by the XR camera to update pose\r\n                this.currentFrame = xrFrame;\r\n                this.onXRFrameObservable.notifyObservers(null);\r\n                this.scene.getEngine()._renderLoop();\r\n            }\r\n        };\r\n\r\n        if (this._xrNavigator.xr.native) {\r\n            this._rttProvider = this._xrNavigator.xr.getNativeRenderTargetProvider(this.session, (width: number, height: number) => {\r\n                return this.scene.getEngine().createRenderTargetTexture({ width: width, height: height }, false);\r\n            });\r\n        } else {\r\n            // Create render target texture from xr's webgl render target\r\n            this._rttProvider = new RenderTargetProvider(WebXRSessionManager._CreateRenderTargetTextureFromSession(this.session, this.scene, this.baseLayer!));\r\n        }\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (window.cancelAnimationFrame) { window.cancelAnimationFrame(this.scene.getEngine()._frameHandler); }\r\n        this.scene.getEngine()._renderLoop();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): RenderTargetTexture {\r\n        return this._rttProvider!.getRenderTargetForEye(eye);\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the renderloop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public exitXRAsync() {\r\n        if (this.session) {\r\n            try {\r\n                return this.session.end();\r\n            } catch (e) {\r\n                Logger.Warn(\"could not end XR session. It has ended already.\");\r\n            }\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns true if supported\r\n     */\r\n    public supportsSessionAsync(sessionMode: XRSessionMode) {\r\n        if (!(navigator as any).xr) {\r\n            return Promise.resolve(false);\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return Promise.resolve(false);\r\n        } else {\r\n            return functionToUse.call((navigator as any).xr, sessionMode).then(() => {\r\n                return Promise.resolve(true);\r\n            }).catch((e: any) => {\r\n                Logger.Warn(e);\r\n                return Promise.resolve(false);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param onStateChangedObservable optional, mechanism for enabling/disabling XR rendering canvas, used only on Web\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(onStateChangedObservable?: Observable<WebXRState>, options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        if (this._xrNavigator.xr.native) {\r\n            return this._xrNavigator.xr.getWebXRRenderTarget(this.scene.getEngine());\r\n        }\r\n        else {\r\n            return new WebXRManagedOutputCanvas(this.scene.getEngine(), this.scene.getEngine().getRenderingCanvas() as HTMLCanvasElement, onStateChangedObservable!, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Converts the render layer of xrSession to a render target\r\n     * @param session session to create render target for\r\n     * @param scene scene the new render target should be created for\r\n     */\r\n    public static _CreateRenderTargetTextureFromSession(session: XRSession, scene: Scene, baseLayer: XRWebGLLayer) {\r\n        if (!baseLayer) {\r\n            throw \"no layer\";\r\n        }\r\n        // Create internal texture\r\n        var internalTexture = new InternalTexture(scene.getEngine(), InternalTextureSource.Unknown, true);\r\n        internalTexture.width = baseLayer.framebufferWidth;\r\n        internalTexture.height = baseLayer.framebufferHeight;\r\n        internalTexture._framebuffer = baseLayer.framebuffer;\r\n\r\n        // Create render target texture from the internal texture\r\n        var renderTargetTexture = new RenderTargetTexture(\"XR renderTargetTexture\", { width: internalTexture.width, height: internalTexture.height }, scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\r\n        renderTargetTexture._texture = internalTexture;\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     */\r\n    public dispose() {\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n    }\r\n}"]}
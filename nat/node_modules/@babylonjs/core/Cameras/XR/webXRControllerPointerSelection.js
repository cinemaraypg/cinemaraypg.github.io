import { Vector3 } from '../../Maths/math.vector';
import { Mesh } from '../../Meshes/mesh';
import { Ray } from '../../Culling/ray';
import { StandardMaterial } from '../../Materials/standardMaterial';
import { Color3 } from '../../Maths/math.color';
import { Axis } from '../../Maths/math.axis';
/**
 * Handles pointer input automatically for the pointer of XR controllers
 */
var WebXRControllerPointerSelection = /** @class */ (function () {
    /**
     * Creates a WebXRControllerPointerSelection
     * @param input input manager to setup pointer selection
     */
    function WebXRControllerPointerSelection(input) {
        var _this = this;
        this._tmpRay = new Ray(new Vector3(), new Vector3());
        input.onControllerAddedObservable.add(function (controller) {
            var scene = controller.pointer.getScene();
            var laserPointer;
            var cursorMesh;
            var triggerDown = false;
            var id;
            id = WebXRControllerPointerSelection._idCounter++;
            // Create a laser pointer for the XR controller
            laserPointer = Mesh.CreateCylinder("laserPointer", 1, 0.0002, 0.004, 20, 1, scene, false);
            laserPointer.parent = controller.pointer;
            var laserPointerMaterial = new StandardMaterial("laserPointerMat", scene);
            laserPointerMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);
            laserPointerMaterial.alpha = 0.6;
            laserPointer.material = laserPointerMaterial;
            laserPointer.rotation.x = Math.PI / 2;
            _this._updatePointerDistance(laserPointer, 1);
            laserPointer.isPickable = false;
            // Create a gaze tracker for the  XR controller
            cursorMesh = Mesh.CreateTorus("gazeTracker", 0.0035 * 3, 0.0025 * 3, 20, scene, false);
            cursorMesh.bakeCurrentTransformIntoVertices();
            cursorMesh.isPickable = false;
            cursorMesh.isVisible = false;
            var targetMat = new StandardMaterial("targetMat", scene);
            targetMat.specularColor = Color3.Black();
            targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);
            targetMat.backFaceCulling = false;
            cursorMesh.material = targetMat;
            var renderObserver = scene.onBeforeRenderObservable.add(function () {
                // Every frame check collisions/input
                controller.getWorldPointerRayToRef(_this._tmpRay);
                var pick = scene.pickWithRay(_this._tmpRay);
                if (pick) {
                    var pressed = false;
                    if (controller.inputSource.gamepad) {
                        if (controller.inputSource.gamepad.buttons[0] && controller.inputSource.gamepad.buttons[0].value > 0.7) {
                            pressed = true;
                        }
                        else if (controller.inputSource.gamepad.buttons[1] && controller.inputSource.gamepad.buttons[1].pressed) {
                            pressed = true;
                        }
                    }
                    if (pressed) {
                        if (!triggerDown) {
                            scene.simulatePointerDown(pick, { pointerId: id });
                        }
                        triggerDown = true;
                    }
                    else {
                        if (triggerDown) {
                            scene.simulatePointerUp(pick, { pointerId: id });
                        }
                        triggerDown = false;
                    }
                    scene.simulatePointerMove(pick, { pointerId: id });
                }
                if (pick && pick.pickedPoint && pick.hit) {
                    // Update laser state
                    _this._updatePointerDistance(laserPointer, pick.distance);
                    // Update cursor state
                    cursorMesh.position.copyFrom(pick.pickedPoint);
                    cursorMesh.scaling.x = Math.sqrt(pick.distance);
                    cursorMesh.scaling.y = Math.sqrt(pick.distance);
                    cursorMesh.scaling.z = Math.sqrt(pick.distance);
                    // To avoid z-fighting
                    var pickNormal = _this._convertNormalToDirectionOfRay(pick.getNormal(), _this._tmpRay);
                    var deltaFighting = 0.002;
                    cursorMesh.position.copyFrom(pick.pickedPoint);
                    if (pickNormal) {
                        var axis1 = Vector3.Cross(Axis.Y, pickNormal);
                        var axis2 = Vector3.Cross(pickNormal, axis1);
                        Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, cursorMesh.rotation);
                        cursorMesh.position.addInPlace(pickNormal.scale(deltaFighting));
                    }
                    cursorMesh.isVisible = true;
                }
                else {
                    cursorMesh.isVisible = false;
                }
            });
            controller.onDisposeObservable.addOnce(function () {
                laserPointer.dispose();
                cursorMesh.dispose();
                scene.onBeforeRenderObservable.remove(renderObserver);
            });
        });
    }
    WebXRControllerPointerSelection.prototype._convertNormalToDirectionOfRay = function (normal, ray) {
        if (normal) {
            var angle = Math.acos(Vector3.Dot(normal, ray.direction));
            if (angle < Math.PI / 2) {
                normal.scaleInPlace(-1);
            }
        }
        return normal;
    };
    WebXRControllerPointerSelection.prototype._updatePointerDistance = function (_laserPointer, distance) {
        if (distance === void 0) { distance = 100; }
        _laserPointer.scaling.y = distance;
        _laserPointer.position.z = distance / 2;
    };
    WebXRControllerPointerSelection._idCounter = 0;
    return WebXRControllerPointerSelection;
}());
export { WebXRControllerPointerSelection };
//# sourceMappingURL=webXRControllerPointerSelection.js.map
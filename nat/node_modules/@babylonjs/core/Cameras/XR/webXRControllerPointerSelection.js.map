{"version":3,"file":"webXRControllerPointerSelection.js","sourceRoot":"","sources":["../../../../sourceES6/core/Cameras/XR/webXRControllerPointerSelection.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Vector3 } from '../../Maths/math.vector';\r\nimport { Mesh } from '../../Meshes/mesh';\r\nimport { Ray } from '../../Culling/ray';\r\nimport { StandardMaterial } from '../../Materials/standardMaterial';\r\nimport { WebXRInput } from './webXRInput';\r\nimport { Color3 } from '../../Maths/math.color';\r\nimport { Axis } from '../../Maths/math.axis';\r\n\r\n/**\r\n * Handles pointer input automatically for the pointer of XR controllers\r\n */\r\nexport class WebXRControllerPointerSelection {\r\n    private static _idCounter = 0;\r\n    private _tmpRay = new Ray(new Vector3(), new Vector3());\r\n\r\n    /**\r\n     * Creates a WebXRControllerPointerSelection\r\n     * @param input input manager to setup pointer selection\r\n     */\r\n    constructor(input: WebXRInput) {\r\n        input.onControllerAddedObservable.add((controller) => {\r\n            let scene = controller.pointer.getScene();\r\n\r\n            let laserPointer: Mesh;\r\n            let cursorMesh: Mesh;\r\n            let triggerDown = false;\r\n            let id: number;\r\n            id = WebXRControllerPointerSelection._idCounter++;\r\n\r\n            // Create a laser pointer for the XR controller\r\n            laserPointer = Mesh.CreateCylinder(\"laserPointer\", 1, 0.0002, 0.004, 20, 1, scene, false);\r\n            laserPointer.parent = controller.pointer;\r\n            let laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", scene);\r\n            laserPointerMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);\r\n            laserPointerMaterial.alpha = 0.6;\r\n            laserPointer.material = laserPointerMaterial;\r\n            laserPointer.rotation.x = Math.PI / 2;\r\n            this._updatePointerDistance(laserPointer, 1);\r\n            laserPointer.isPickable = false;\r\n\r\n            // Create a gaze tracker for the  XR controller\r\n            cursorMesh = Mesh.CreateTorus(\"gazeTracker\", 0.0035 * 3, 0.0025 * 3, 20, scene, false);\r\n            cursorMesh.bakeCurrentTransformIntoVertices();\r\n            cursorMesh.isPickable = false;\r\n            cursorMesh.isVisible = false;\r\n            let targetMat = new StandardMaterial(\"targetMat\", scene);\r\n            targetMat.specularColor = Color3.Black();\r\n            targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);\r\n            targetMat.backFaceCulling = false;\r\n            cursorMesh.material = targetMat;\r\n\r\n            let renderObserver = scene.onBeforeRenderObservable.add(() => {\r\n                // Every frame check collisions/input\r\n                controller.getWorldPointerRayToRef(this._tmpRay);\r\n                let pick = scene.pickWithRay(this._tmpRay);\r\n                if (pick) {\r\n                    let pressed = false;\r\n                    if (controller.inputSource.gamepad) {\r\n                        if (controller.inputSource.gamepad.buttons[0] && controller.inputSource.gamepad.buttons[0].value > 0.7) {\r\n                            pressed = true;\r\n                        } else if (controller.inputSource.gamepad.buttons[1] && controller.inputSource.gamepad.buttons[1].pressed) {\r\n                            pressed = true;\r\n                        }\r\n                    }\r\n                    if (pressed) {\r\n                        if (!triggerDown) {\r\n                            scene.simulatePointerDown(pick, { pointerId: id });\r\n                        }\r\n                        triggerDown = true;\r\n                    } else {\r\n                        if (triggerDown) {\r\n                            scene.simulatePointerUp(pick, { pointerId: id });\r\n                        }\r\n                        triggerDown = false;\r\n                    }\r\n                    scene.simulatePointerMove(pick, { pointerId: id });\r\n                }\r\n\r\n                if (pick && pick.pickedPoint && pick.hit) {\r\n                    // Update laser state\r\n                    this._updatePointerDistance(laserPointer, pick.distance);\r\n\r\n                    // Update cursor state\r\n                    cursorMesh.position.copyFrom(pick.pickedPoint);\r\n                    cursorMesh.scaling.x = Math.sqrt(pick.distance);\r\n                    cursorMesh.scaling.y = Math.sqrt(pick.distance);\r\n                    cursorMesh.scaling.z = Math.sqrt(pick.distance);\r\n\r\n                    // To avoid z-fighting\r\n                    let pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(), this._tmpRay);\r\n                    let deltaFighting = 0.002;\r\n                    cursorMesh.position.copyFrom(pick.pickedPoint);\r\n                    if (pickNormal) {\r\n                        let axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                        let axis2 = Vector3.Cross(pickNormal, axis1);\r\n                        Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, cursorMesh.rotation);\r\n                        cursorMesh.position.addInPlace(pickNormal.scale(deltaFighting));\r\n                    }\r\n                    cursorMesh.isVisible = true;\r\n                } else {\r\n                    cursorMesh.isVisible = false;\r\n                }\r\n            });\r\n\r\n            controller.onDisposeObservable.addOnce(() => {\r\n                laserPointer.dispose();\r\n                cursorMesh.dispose();\r\n\r\n                scene.onBeforeRenderObservable.remove(renderObserver);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            let angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _updatePointerDistance(_laserPointer: Mesh, distance: number = 100) {\r\n        _laserPointer.scaling.y = distance;\r\n        _laserPointer.position.z = distance / 2;\r\n    }\r\n}"]}
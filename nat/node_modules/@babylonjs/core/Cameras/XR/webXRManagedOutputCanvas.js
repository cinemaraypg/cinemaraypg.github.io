import { WebXRState } from "./webXRTypes";
/**
 * COnfiguration object for WebXR output canvas
 */
var WebXRManagedOutputCanvasOptions = /** @class */ (function () {
    function WebXRManagedOutputCanvasOptions() {
    }
    /**
     * Get the default values of the configuration object
     * @returns default values of this configuration object
     */
    WebXRManagedOutputCanvasOptions.GetDefaults = function () {
        var defaults = new WebXRManagedOutputCanvasOptions();
        defaults.canvasOptions = {
            antialias: true,
            depth: true,
            stencil: false,
            alpha: true,
            multiview: false,
            framebufferScaleFactor: 1
        };
        defaults.newCanvasCssStyle = "position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;";
        return defaults;
    };
    return WebXRManagedOutputCanvasOptions;
}());
export { WebXRManagedOutputCanvasOptions };
/**
 * Creates a canvas that is added/removed from the webpage when entering/exiting XR
 */
var WebXRManagedOutputCanvas = /** @class */ (function () {
    /**
     * Initializes the canvas to be added/removed upon entering/exiting xr
     * @param engine the Babylon engine
     * @param canvas The canvas to be added/removed (If not specified a full screen canvas will be created)
     * @param onStateChangedObservable the mechanism by which the canvas will be added/removed based on XR state
     * @param configuration optional configuration for this canvas output. defaults will be used if not provided
     */
    function WebXRManagedOutputCanvas(engine, canvas, onStateChangedObservable, configuration) {
        var _this = this;
        if (configuration === void 0) { configuration = WebXRManagedOutputCanvasOptions.GetDefaults(); }
        this.configuration = configuration;
        this._canvas = null;
        /**
         * xr layer for the canvas
         */
        this.xrLayer = null;
        this._engine = engine;
        if (!canvas) {
            canvas = document.createElement('canvas');
            canvas.style.cssText = this.configuration.newCanvasCssStyle || "position:absolute; bottom:0px;right:0px;";
        }
        this._setManagedOutputCanvas(canvas);
        if (onStateChangedObservable) {
            onStateChangedObservable.add(function (stateInfo) {
                if (stateInfo == WebXRState.ENTERING_XR) {
                    // The canvas is added to the screen before entering XR because currently the xr session must be initialized while the canvas is added render properly
                    _this._addCanvas();
                }
                else if (stateInfo == WebXRState.NOT_IN_XR) {
                    _this._removeCanvas();
                }
            });
        }
    }
    /**
     * Initializes the xr layer for the session
     * @param xrSession xr session
     * @returns a promise that will resolve once the XR Layer has been created
     */
    WebXRManagedOutputCanvas.prototype.initializeXRLayerAsync = function (xrSession) {
        var _this = this;
        var createLayer = function () {
            return _this.xrLayer = new XRWebGLLayer(xrSession, _this.canvasContext, _this.configuration.canvasOptions);
        };
        // support canvases without makeXRCompatible
        if (!this.canvasContext.makeXRCompatible) {
            this.xrLayer = createLayer();
            return Promise.resolve(true);
        }
        return this.canvasContext.makeXRCompatible().then(function () {
            _this.xrLayer = createLayer();
            return _this.xrLayer;
        });
    };
    /**
     * Disposes of the object
     */
    WebXRManagedOutputCanvas.prototype.dispose = function () {
        this._removeCanvas();
        this._setManagedOutputCanvas(null);
    };
    WebXRManagedOutputCanvas.prototype._setManagedOutputCanvas = function (canvas) {
        this._removeCanvas();
        if (!canvas) {
            this._canvas = null;
            this.canvasContext = null;
        }
        else {
            this._canvas = canvas;
            this.canvasContext = this._canvas.getContext('webgl');
            if (!this.canvasContext) {
                this.canvasContext = this._canvas.getContext('webgl2');
            }
        }
    };
    WebXRManagedOutputCanvas.prototype._addCanvas = function () {
        if (this._canvas && this._canvas !== this._engine.getRenderingCanvas()) {
            document.body.appendChild(this._canvas);
        }
    };
    WebXRManagedOutputCanvas.prototype._removeCanvas = function () {
        if (this._canvas && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {
            document.body.removeChild(this._canvas);
        }
    };
    return WebXRManagedOutputCanvas;
}());
export { WebXRManagedOutputCanvas };
//# sourceMappingURL=webXRManagedOutputCanvas.js.map
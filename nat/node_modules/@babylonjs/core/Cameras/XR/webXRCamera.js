import { __extends } from "tslib";
import { Vector3, Matrix, Quaternion } from "../../Maths/math.vector";
import { Camera } from "../../Cameras/camera";
import { FreeCamera } from "../../Cameras/freeCamera";
import { TargetCamera } from "../../Cameras/targetCamera";
import { Viewport } from '../../Maths/math.viewport';
/**
 * WebXR Camera which holds the views for the xrSession
 * @see https://doc.babylonjs.com/how_to/webxr
 */
var WebXRCamera = /** @class */ (function (_super) {
    __extends(WebXRCamera, _super);
    /**
     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager
     * @param name the name of the camera
     * @param scene the scene to add the camera to
     */
    function WebXRCamera(name, scene) {
        var _this = _super.call(this, name, Vector3.Zero(), scene) || this;
        /**
         * Is the camera in debug mode. Used when using an emulator
         */
        _this.debugMode = false;
        // Initial camera configuration
        _this.minZ = 0.1;
        _this.rotationQuaternion = new Quaternion();
        _this.cameraRigMode = Camera.RIG_MODE_CUSTOM;
        _this.updateUpVectorFromRotation = true;
        _this._updateNumberOfRigCameras(1);
        return _this;
    }
    WebXRCamera.prototype._updateNumberOfRigCameras = function (viewCount) {
        if (viewCount === void 0) { viewCount = 1; }
        while (this.rigCameras.length < viewCount) {
            var newCamera = new TargetCamera("view: " + this.rigCameras.length, Vector3.Zero(), this.getScene());
            newCamera.minZ = 0.1;
            newCamera.parent = this;
            newCamera.rotationQuaternion = new Quaternion();
            newCamera.updateUpVectorFromRotation = true;
            this.rigCameras.push(newCamera);
        }
        while (this.rigCameras.length > viewCount) {
            var removedCamera = this.rigCameras.pop();
            if (removedCamera) {
                removedCamera.dispose();
            }
        }
    };
    /** @hidden */
    WebXRCamera.prototype._updateForDualEyeDebugging = function ( /*pupilDistance = 0.01*/) {
        // Create initial camera rigs
        this._updateNumberOfRigCameras(2);
        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);
        // this.rigCameras[0].position.x = -pupilDistance / 2;
        this.rigCameras[0].outputRenderTarget = null;
        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);
        // this.rigCameras[1].position.x = pupilDistance / 2;
        this.rigCameras[1].outputRenderTarget = null;
    };
    /**
     * Updates the cameras position from the current pose information of the  XR session
     * @param xrSessionManager the session containing pose information
     * @returns true if the camera has been updated, false if the session did not contain pose or frame data
     */
    WebXRCamera.prototype.updateFromXRSessionManager = function (xrSessionManager) {
        var _this = this;
        // Ensure all frame data is available
        if (!xrSessionManager.currentFrame || !xrSessionManager.currentFrame.getViewerPose) {
            return false;
        }
        var pose = xrSessionManager.currentFrame.getViewerPose(xrSessionManager.referenceSpace);
        if (!pose) {
            return false;
        }
        if (pose.transform && pose.emulatedPosition) {
            this.position.copyFrom((pose.transform.position));
            this.rotationQuaternion.copyFrom((pose.transform.orientation));
            if (!this._scene.useRightHandedSystem) {
                this.position.z *= -1;
                this.rotationQuaternion.z *= -1;
                this.rotationQuaternion.w *= -1;
            }
            this.computeWorldMatrix();
        }
        // Update camera rigs
        this._updateNumberOfRigCameras(pose.views.length);
        pose.views.forEach(function (view, i) {
            var currentRig = _this.rigCameras[i];
            // Update view/projection matrix
            if (view.transform.position && view.transform.orientation) {
                currentRig.position.copyFrom(view.transform.position);
                currentRig.rotationQuaternion.copyFrom(view.transform.orientation);
                if (!_this._scene.useRightHandedSystem) {
                    currentRig.position.z *= -1;
                    currentRig.rotationQuaternion.z *= -1;
                    currentRig.rotationQuaternion.w *= -1;
                }
            }
            else {
                Matrix.FromFloat32ArrayToRefScaled(view.transform.matrix, 0, 1, currentRig._computedViewMatrix);
                if (!_this._scene.useRightHandedSystem) {
                    currentRig._computedViewMatrix.toggleModelMatrixHandInPlace();
                }
            }
            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);
            if (!_this._scene.useRightHandedSystem) {
                currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();
            }
            // Update viewport
            if (xrSessionManager.session.renderState.baseLayer) {
                var viewport = xrSessionManager.session.renderState.baseLayer.getViewport(view);
                var width = xrSessionManager.session.renderState.baseLayer.framebufferWidth;
                var height = xrSessionManager.session.renderState.baseLayer.framebufferHeight;
                currentRig.viewport.width = viewport.width / width;
                currentRig.viewport.height = viewport.height / height;
                currentRig.viewport.x = viewport.x / width;
                currentRig.viewport.y = viewport.y / height;
            }
            if (_this.debugMode) {
                _this._updateForDualEyeDebugging();
            }
            // Set cameras to render to the session's render target
            currentRig.outputRenderTarget = xrSessionManager.getRenderTargetTextureForEye(view.eye);
        });
        return true;
    };
    return WebXRCamera;
}(FreeCamera));
export { WebXRCamera };
//# sourceMappingURL=webXRCamera.js.map
import { Observable } from "../../Misc/observable";
import { IDisposable, Scene } from "../../scene";
import { Quaternion, Vector3 } from "../../Maths/math.vector";
import { AbstractMesh } from "../../Meshes/abstractMesh";
import { WebXRSessionManager } from "./webXRSessionManager";
import { WebXRCamera } from "./webXRCamera";
import { WebXRState, WebXRRenderTarget } from './webXRTypes';
/**
 * Base set of functionality needed to create an XR experince (WebXRSessionManager, Camera, StateManagement, etc.)
 * @see https://doc.babylonjs.com/how_to/webxr
 */
export declare class WebXRExperienceHelper implements IDisposable {
    private scene;
    /**
     * Container which stores the xr camera and controllers as children. This can be used to move the camera/user as the camera's position is updated by the xr device
     */
    container: AbstractMesh;
    /**
     * Camera used to render xr content
     */
    camera: WebXRCamera;
    /**
     * The current state of the XR experience (eg. transitioning, in XR or not in XR)
     */
    state: WebXRState;
    private _setState;
    private static _TmpVector;
    /**
     * Fires when the state of the experience helper has changed
     */
    onStateChangedObservable: Observable<WebXRState>;
    /** Session manager used to keep track of xr session */
    sessionManager: WebXRSessionManager;
    private _nonVRCamera;
    private _originalSceneAutoClear;
    private _supported;
    /**
     * Creates the experience helper
     * @param scene the scene to attach the experience helper to
     * @returns a promise for the experience helper
     */
    static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper>;
    /**
     * Creates a WebXRExperienceHelper
     * @param scene The scene the helper should be created in
     */
    private constructor();
    /**
     * Exits XR mode and returns the scene to its original state
     * @returns promise that resolves after xr mode has exited
     */
    exitXRAsync(): Promise<void>;
    /**
     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)
     * @param sessionMode options for the XR session
     * @param referenceSpaceType frame of reference of the XR session
     * @param renderTarget the output canvas that will be used to enter XR mode
     * @returns promise that resolves after xr mode has entered
     */
    enterXRAsync(sessionMode: XRSessionMode, referenceSpaceType: XRReferenceSpaceType, renderTarget: WebXRRenderTarget): Promise<WebXRSessionManager>;
    /**
     * Updates the global position of the camera by moving the camera's container
     * This should be used instead of modifying the camera's position as it will be overwritten by an xrSessions's update frame
     * @param position The desired global position of the camera
     */
    setPositionOfCameraUsingContainer(position: Vector3): void;
    /**
     * Rotates the xr camera by rotating the camera's container around the camera's position
     * This should be used instead of modifying the camera's rotation as it will be overwritten by an xrSessions's update frame
     * @param rotation the desired quaternion rotation to apply to the camera
     */
    rotateCameraByQuaternionUsingContainer(rotation: Quaternion): void;
    /**
     * Disposes of the experience helper
     */
    dispose(): void;
}

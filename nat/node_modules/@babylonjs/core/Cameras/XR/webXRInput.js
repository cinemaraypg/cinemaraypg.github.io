import { Observable } from "../../Misc/observable";
import { WebXRController } from './webXRController';
import { WebXRState } from './webXRTypes';
/**
 * XR input used to track XR inputs such as controllers/rays
 */
var WebXRInput = /** @class */ (function () {
    /**
     * Initializes the WebXRInput
     * @param baseExperience experience helper which the input should be created for
     */
    function WebXRInput(
    /**
     * Base experience the input listens to
     */
    baseExperience) {
        var _this = this;
        this.baseExperience = baseExperience;
        /**
         * XR controllers being tracked
         */
        this.controllers = [];
        /**
         * Event when a controller has been connected/added
         */
        this.onControllerAddedObservable = new Observable();
        /**
         * Event when a controller has been removed/disconnected
         */
        this.onControllerRemovedObservable = new Observable();
        this._onInputSourcesChange = function (event) {
            _this._addAndRemoveControllers(event.added, event.removed);
        };
        // Remove controllers when exiting XR
        this._stateObserver = baseExperience.onStateChangedObservable.add(function (s) {
            if (s === WebXRState.NOT_IN_XR) {
                _this._addAndRemoveControllers([], _this.controllers.map(function (c) { return c.inputSource; }));
            }
        });
        this._frameObserver = baseExperience.sessionManager.onXRFrameObservable.add(function () {
            if (!baseExperience.sessionManager.currentFrame) {
                return;
            }
            // Start listing to input add/remove event
            if (_this.controllers.length == 0 && baseExperience.sessionManager.session.inputSources) {
                _this._addAndRemoveControllers(baseExperience.sessionManager.session.inputSources, []);
                baseExperience.sessionManager.session.addEventListener("inputsourceschange", _this._onInputSourcesChange);
            }
            // Update controller pose info
            _this.controllers.forEach(function (controller) {
                controller.updateFromXRFrame(baseExperience.sessionManager.currentFrame, baseExperience.sessionManager.referenceSpace);
            });
        });
    }
    WebXRInput.prototype._addAndRemoveControllers = function (addInputs, removeInputs) {
        var _this = this;
        // Add controllers if they don't already exist
        var sources = this.controllers.map(function (c) { return c.inputSource; });
        for (var _i = 0, addInputs_1 = addInputs; _i < addInputs_1.length; _i++) {
            var input = addInputs_1[_i];
            if (sources.indexOf(input) === -1) {
                var controller = new WebXRController(this.baseExperience.camera._scene, input, this.baseExperience.container);
                this.controllers.push(controller);
                this.onControllerAddedObservable.notifyObservers(controller);
            }
        }
        // Remove and dispose of controllers to be disposed
        var keepControllers = [];
        var removedControllers = [];
        this.controllers.forEach(function (c) {
            if (removeInputs.indexOf(c.inputSource) === -1) {
                keepControllers.push(c);
            }
            else {
                removedControllers.push(c);
            }
        });
        this.controllers = keepControllers;
        removedControllers.forEach(function (c) {
            _this.onControllerRemovedObservable.notifyObservers(c);
            c.dispose();
        });
    };
    /**
     * Disposes of the object
     */
    WebXRInput.prototype.dispose = function () {
        this.controllers.forEach(function (c) {
            c.dispose();
        });
        this.baseExperience.sessionManager.onXRFrameObservable.remove(this._frameObserver);
        this.baseExperience.onStateChangedObservable.remove(this._stateObserver);
    };
    return WebXRInput;
}());
export { WebXRInput };
//# sourceMappingURL=webXRInput.js.map
import { Observable } from "../../Misc/observable";
import { AbstractMesh } from "../../Meshes/abstractMesh";
import { Matrix, Quaternion, Vector3 } from '../../Maths/math.vector';
/**
 * Represents an XR input
 */
var WebXRController = /** @class */ (function () {
    /**
     * Creates the controller
     * @see https://doc.babylonjs.com/how_to/webxr
     * @param scene the scene which the controller should be associated to
     * @param inputSource the underlying input source for the controller
     * @param parentContainer parent that the controller meshes should be children of
     */
    function WebXRController(scene, 
    /** The underlying input source for the controller  */
    inputSource, parentContainer) {
        if (parentContainer === void 0) { parentContainer = null; }
        this.scene = scene;
        this.inputSource = inputSource;
        this.parentContainer = parentContainer;
        this._gamepadMode = false;
        /**
         * Event that fires when the controller is removed/disposed
         */
        this.onDisposeObservable = new Observable();
        this._tmpMatrix = new Matrix();
        this._tmpQuaternion = new Quaternion();
        this._tmpVector = new Vector3();
        this.pointer = new AbstractMesh("controllerPointer", scene);
        this.pointer.rotationQuaternion = new Quaternion();
        if (parentContainer) {
            parentContainer.addChild(this.pointer);
        }
        if (this.inputSource.gripSpace) {
            this.grip = new AbstractMesh("controllerGrip", this.scene);
            if (this.parentContainer) {
                this.parentContainer.addChild(this.grip);
            }
        }
        else if (this.inputSource.gamepad) {
            this._gamepadMode = true;
        }
    }
    /**
     * Updates the controller pose based on the given XRFrame
     * @param xrFrame xr frame to update the pose with
     * @param referenceSpace reference space to use
     */
    WebXRController.prototype.updateFromXRFrame = function (xrFrame, referenceSpace) {
        var pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);
        // Update the pointer mesh
        if (pose) {
            this.pointer.position.copyFrom((pose.transform.position));
            this.pointer.rotationQuaternion.copyFrom((pose.transform.orientation));
            if (!this.scene.useRightHandedSystem) {
                this.pointer.position.z *= -1;
                this.pointer.rotationQuaternion.z *= -1;
                this.pointer.rotationQuaternion.w *= -1;
            }
        }
        // Update the grip mesh if it exists
        if (this.inputSource.gripSpace && this.grip) {
            var pose_1 = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);
            if (pose_1) {
                Matrix.FromFloat32ArrayToRefScaled(pose_1.transform.matrix, 0, 1, this._tmpMatrix);
                if (!this.scene.useRightHandedSystem) {
                    this._tmpMatrix.toggleModelMatrixHandInPlace();
                }
                if (!this.grip.rotationQuaternion) {
                    this.grip.rotationQuaternion = new Quaternion();
                }
                this._tmpMatrix.decompose(this.grip.scaling, this.grip.rotationQuaternion, this.grip.position);
            }
        }
        if (this.gamepadController) {
            // either update buttons only or also position, if in gamepad mode
            this.gamepadController.isXR = !this._gamepadMode;
            this.gamepadController.update();
            this.gamepadController.isXR = true;
        }
    };
    /**
     * Gets a world space ray coming from the controller
     * @param result the resulting ray
     */
    WebXRController.prototype.getWorldPointerRayToRef = function (result) {
        // Force update to ensure picked point is synced with ray
        var worldMatrix = this.pointer.computeWorldMatrix(true);
        worldMatrix.decompose(undefined, this._tmpQuaternion, undefined);
        this._tmpVector.set(0, 0, 1);
        this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);
        result.origin = this.pointer.absolutePosition;
        result.direction.copyFrom(this._tmpVector);
        result.length = 1000;
    };
    /**
     * Get the scene associated with this controller
     * @returns the scene object
     */
    WebXRController.prototype.getScene = function () {
        return this.scene;
    };
    /**
     * Disposes of the object
     */
    WebXRController.prototype.dispose = function () {
        if (this.grip) {
            this.grip.dispose();
        }
        if (this.gamepadController && this._gamepadMode) {
            this.gamepadController.dispose();
        }
        this.pointer.dispose();
        this.onDisposeObservable.notifyObservers({});
    };
    return WebXRController;
}());
export { WebXRController };
//# sourceMappingURL=webXRController.js.map
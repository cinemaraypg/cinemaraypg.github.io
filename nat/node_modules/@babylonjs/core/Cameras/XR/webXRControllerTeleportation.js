import { Quaternion, Vector3 } from '../../Maths/math.vector';
import { Mesh } from '../../Meshes/mesh';
import { Ray } from '../../Culling/ray';
import { StandardMaterial } from '../../Materials/standardMaterial';
import { DynamicTexture } from '../../Materials/Textures/dynamicTexture';
import { EasingFunction, SineEase } from '../../Animations/easing';
import { Animation } from '../../Animations/animation';
/**
 * Enables teleportation
 */
var WebXRControllerTeleportation = /** @class */ (function () {
    /**
     * Creates a WebXRControllerTeleportation
     * @param input input manager to add teleportation to
     * @param floorMeshes floormeshes which can be teleported to
     */
    function WebXRControllerTeleportation(input, floorMeshes) {
        var _this = this;
        if (floorMeshes === void 0) { floorMeshes = []; }
        this._teleportationFillColor = "#444444";
        this._teleportationBorderColor = "#FFFFFF";
        this._tmpRay = new Ray(new Vector3(), new Vector3());
        this._tmpVector = new Vector3();
        input.onControllerAddedObservable.add(function (c) {
            var scene = c.pointer.getScene();
            var forwardReadyToTeleport = false;
            var backwardReadyToTeleport = false;
            var leftReadyToTeleport = false;
            var rightReadyToTeleport = false;
            // Teleport target abd it's animation
            var teleportationTarget = Mesh.CreateGround("teleportationTarget", 2, 2, 2, scene);
            teleportationTarget.isPickable = false;
            var length = 512;
            var dynamicTexture = new DynamicTexture("DynamicTexture", length, scene, true);
            dynamicTexture.hasAlpha = true;
            var context = dynamicTexture.getContext();
            var centerX = length / 2;
            var centerY = length / 2;
            var radius = 200;
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
            context.fillStyle = _this._teleportationFillColor;
            context.fill();
            context.lineWidth = 10;
            context.strokeStyle = _this._teleportationBorderColor;
            context.stroke();
            context.closePath();
            dynamicTexture.update();
            var teleportationCircleMaterial = new StandardMaterial("TextPlaneMaterial", scene);
            teleportationCircleMaterial.diffuseTexture = dynamicTexture;
            teleportationTarget.material = teleportationCircleMaterial;
            var torus = Mesh.CreateTorus("torusTeleportation", 0.75, 0.1, 25, scene, false);
            torus.isPickable = false;
            torus.parent = teleportationTarget;
            var animationInnerCircle = new Animation("animationInnerCircle", "position.y", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
            var keys = [];
            keys.push({
                frame: 0,
                value: 0
            });
            keys.push({
                frame: 30,
                value: 0.4
            });
            keys.push({
                frame: 60,
                value: 0
            });
            animationInnerCircle.setKeys(keys);
            var easingFunction = new SineEase();
            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
            animationInnerCircle.setEasingFunction(easingFunction);
            torus.animations = [];
            torus.animations.push(animationInnerCircle);
            scene.beginAnimation(torus, 0, 60, true);
            // Handle user input on every frame
            var renderObserver = scene.onBeforeRenderObservable.add(function () {
                // Move the teleportationTarget to where the user is targetting to teleport to
                if (forwardReadyToTeleport) {
                    c.getWorldPointerRayToRef(_this._tmpRay);
                    var pick = scene.pickWithRay(_this._tmpRay, function (o) {
                        return floorMeshes.indexOf(o) !== -1;
                    });
                    if (pick && pick.pickedPoint) {
                        // To avoid z-fighting
                        teleportationTarget.position.copyFrom(pick.pickedPoint);
                        teleportationTarget.position.y += 0.002;
                    }
                    teleportationTarget.isVisible = true;
                    teleportationTarget.getChildren()[0].isVisible = true;
                }
                else {
                    teleportationTarget.isVisible = false;
                    teleportationTarget.getChildren()[0].isVisible = false;
                }
                if (c.inputSource.gamepad) {
                    if (c.inputSource.gamepad.axes[1] !== undefined) {
                        // Forward teleportation
                        if (c.inputSource.gamepad.axes[1] < -0.7) {
                            forwardReadyToTeleport = true;
                        }
                        else {
                            if (forwardReadyToTeleport) {
                                // Teleport the users feet to where they targetted
                                _this._tmpVector.copyFrom(teleportationTarget.position);
                                _this._tmpVector.y += input.baseExperience.camera.position.y;
                                input.baseExperience.setPositionOfCameraUsingContainer(_this._tmpVector);
                            }
                            forwardReadyToTeleport = false;
                        }
                        // Backward teleportation
                        if (c.inputSource.gamepad.axes[1] > 0.7) {
                            backwardReadyToTeleport = true;
                        }
                        else {
                            if (backwardReadyToTeleport) {
                                // Cast a ray down from behind the user
                                var camMat = input.baseExperience.camera.computeWorldMatrix();
                                var q = new Quaternion();
                                camMat.decompose(undefined, q, _this._tmpRay.origin);
                                _this._tmpVector.set(0, 0, -1);
                                _this._tmpVector.rotateByQuaternionToRef(q, _this._tmpVector);
                                _this._tmpVector.y = 0;
                                _this._tmpVector.normalize();
                                _this._tmpVector.y = -1.5;
                                _this._tmpVector.normalize();
                                _this._tmpRay.direction.copyFrom(_this._tmpVector);
                                var pick = scene.pickWithRay(_this._tmpRay, function (o) {
                                    return floorMeshes.indexOf(o) !== -1;
                                });
                                if (pick && pick.pickedPoint) {
                                    // Teleport the users feet to where they targetted
                                    _this._tmpVector.copyFrom(pick.pickedPoint);
                                    _this._tmpVector.y += input.baseExperience.camera.position.y;
                                    input.baseExperience.setPositionOfCameraUsingContainer(_this._tmpVector);
                                }
                            }
                            backwardReadyToTeleport = false;
                        }
                    }
                    if (c.inputSource.gamepad.axes[0] !== undefined) {
                        if (c.inputSource.gamepad.axes[0] < -0.7) {
                            leftReadyToTeleport = true;
                        }
                        else {
                            if (leftReadyToTeleport) {
                                input.baseExperience.rotateCameraByQuaternionUsingContainer(Quaternion.FromEulerAngles(0, -Math.PI / 4, 0));
                            }
                            leftReadyToTeleport = false;
                        }
                        if (c.inputSource.gamepad.axes[0] > 0.7) {
                            rightReadyToTeleport = true;
                        }
                        else {
                            if (rightReadyToTeleport) {
                                input.baseExperience.rotateCameraByQuaternionUsingContainer(Quaternion.FromEulerAngles(0, Math.PI / 4, 0));
                            }
                            rightReadyToTeleport = false;
                        }
                    }
                }
            });
            c.onDisposeObservable.addOnce(function () {
                teleportationTarget.dispose();
                dynamicTexture.dispose();
                teleportationCircleMaterial.dispose();
                torus.dispose();
                scene.onBeforeRenderObservable.remove(renderObserver);
            });
        });
    }
    return WebXRControllerTeleportation;
}());
export { WebXRControllerTeleportation };
//# sourceMappingURL=webXRControllerTeleportation.js.map
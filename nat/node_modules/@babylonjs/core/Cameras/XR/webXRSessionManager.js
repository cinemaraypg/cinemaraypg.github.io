import { Logger } from "../../Misc/logger";
import { Observable } from "../../Misc/observable";
import { InternalTexture, InternalTextureSource } from "../../Materials/Textures/internalTexture";
import { RenderTargetTexture } from "../../Materials/Textures/renderTargetTexture";
import { WebXRManagedOutputCanvas } from './webXRManagedOutputCanvas';
var RenderTargetProvider = /** @class */ (function () {
    function RenderTargetProvider(texture) {
        this._texture = texture;
    }
    RenderTargetProvider.prototype.getRenderTargetForEye = function (eye) {
        return this._texture;
    };
    return RenderTargetProvider;
}());
/**
 * Manages an XRSession to work with Babylon's engine
 * @see https://doc.babylonjs.com/how_to/webxr
 */
var WebXRSessionManager = /** @class */ (function () {
    /**
     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage
     * @param scene The scene which the session should be created for
     */
    function WebXRSessionManager(scene) {
        this.scene = scene;
        /**
         * Fires every time a new xrFrame arrives which can be used to update the camera
         */
        this.onXRFrameObservable = new Observable();
        /**
         * Fires when the xr session is ended either by the device or manually done
         */
        this.onXRSessionEnded = new Observable();
        this.baseLayer = null;
        this._sessionEnded = false;
    }
    /**
     * Initializes the manager
     * After initialization enterXR can be called to start an XR session
     * @returns Promise which resolves after it is initialized
     */
    WebXRSessionManager.prototype.initializeAsync = function () {
        Logger.Warn("The WebXR APIs are still under development and are subject to change in the future.");
        // Check if the browser supports webXR
        this._xrNavigator = navigator;
        if (!this._xrNavigator.xr) {
            return Promise.reject("webXR not supported by this browser");
        }
        return Promise.resolve();
    };
    /**
     * Initializes an xr session
     * @param xrSessionMode mode to initialize
     * @param optionalFeatures defines optional values to pass to the session builder
     * @returns a promise which will resolve once the session has been initialized
     */
    WebXRSessionManager.prototype.initializeSessionAsync = function (xrSessionMode, optionalFeatures) {
        var _this = this;
        if (optionalFeatures === void 0) { optionalFeatures = {}; }
        return this._xrNavigator.xr.requestSession(xrSessionMode, optionalFeatures).then(function (session) {
            _this.session = session;
            _this._sessionEnded = false;
            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)
            _this.session.addEventListener("end", function () {
                _this._sessionEnded = true;
                // Remove render target texture and notify frame obervers
                _this._rttProvider = null;
                // Restore frame buffer to avoid clear on xr framebuffer after session end
                _this.scene.getEngine().restoreDefaultFramebuffer();
                // Need to restart render loop as after the session is ended the last request for new frame will never call callback
                _this.scene.getEngine().customAnimationFrameRequester = null;
                _this.onXRSessionEnded.notifyObservers(null);
                _this.scene.getEngine()._renderLoop();
            }, { once: true });
            return _this.session;
        });
    };
    /**
     * Sets the reference space on the xr session
     * @param referenceSpace space to set
     * @returns a promise that will resolve once the reference space has been set
     */
    WebXRSessionManager.prototype.setReferenceSpaceAsync = function (referenceSpace) {
        var _this = this;
        return this.session.requestReferenceSpace(referenceSpace).then(function (referenceSpace) {
            _this.referenceSpace = referenceSpace;
        }, function (rejectionReason) {
            Logger.Error("XR.requestReferenceSpace failed for the following reason: ");
            Logger.Error(rejectionReason);
            Logger.Log("Defaulting to universally-supported \"viewer\" reference space type.");
            return _this.session.requestReferenceSpace("viewer").then(function (referenceSpace) {
                _this.referenceSpace = referenceSpace;
            }, function (rejectionReason) {
                Logger.Error(rejectionReason);
                throw "XR initialization failed: required \"viewer\" reference space type not supported.";
            });
        });
    };
    /**
     * Updates the render state of the session
     * @param state state to set
     * @returns a promise that resolves once the render state has been updated
     */
    WebXRSessionManager.prototype.updateRenderStateAsync = function (state) {
        if (state.baseLayer) {
            this.baseLayer = state.baseLayer;
        }
        return this.session.updateRenderState(state);
    };
    /**
     * Starts rendering to the xr layer
     * @returns a promise that will resolve once rendering has started
     */
    WebXRSessionManager.prototype.startRenderingToXRAsync = function () {
        var _this = this;
        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information
        this.scene.getEngine().customAnimationFrameRequester = {
            requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),
            renderFunction: function (timestamp, xrFrame) {
                if (_this._sessionEnded) {
                    return;
                }
                // Store the XR frame in the manager to be consumed by the XR camera to update pose
                _this.currentFrame = xrFrame;
                _this.onXRFrameObservable.notifyObservers(null);
                _this.scene.getEngine()._renderLoop();
            }
        };
        if (this._xrNavigator.xr.native) {
            this._rttProvider = this._xrNavigator.xr.getNativeRenderTargetProvider(this.session, function (width, height) {
                return _this.scene.getEngine().createRenderTargetTexture({ width: width, height: height }, false);
            });
        }
        else {
            // Create render target texture from xr's webgl render target
            this._rttProvider = new RenderTargetProvider(WebXRSessionManager._CreateRenderTargetTextureFromSession(this.session, this.scene, this.baseLayer));
        }
        // Stop window's animation frame and trigger sessions animation frame
        if (window.cancelAnimationFrame) {
            window.cancelAnimationFrame(this.scene.getEngine()._frameHandler);
        }
        this.scene.getEngine()._renderLoop();
        return Promise.resolve();
    };
    /**
     * Gets the correct render target texture to be rendered this frame for this eye
     * @param eye the eye for which to get the render target
     * @returns the render target for the specified eye
     */
    WebXRSessionManager.prototype.getRenderTargetTextureForEye = function (eye) {
        return this._rttProvider.getRenderTargetForEye(eye);
    };
    /**
     * Stops the xrSession and restores the renderloop
     * @returns Promise which resolves after it exits XR
     */
    WebXRSessionManager.prototype.exitXRAsync = function () {
        if (this.session) {
            try {
                return this.session.end();
            }
            catch (e) {
                Logger.Warn("could not end XR session. It has ended already.");
            }
        }
        return Promise.resolve();
    };
    /**
     * Checks if a session would be supported for the creation options specified
     * @param sessionMode session mode to check if supported eg. immersive-vr
     * @returns true if supported
     */
    WebXRSessionManager.prototype.supportsSessionAsync = function (sessionMode) {
        if (!navigator.xr) {
            return Promise.resolve(false);
        }
        // When the specs are final, remove supportsSession!
        var functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;
        if (!functionToUse) {
            return Promise.resolve(false);
        }
        else {
            return functionToUse.call(navigator.xr, sessionMode).then(function () {
                return Promise.resolve(true);
            }).catch(function (e) {
                Logger.Warn(e);
                return Promise.resolve(false);
            });
        }
    };
    /**
     * Creates a WebXRRenderTarget object for the XR session
     * @param onStateChangedObservable optional, mechanism for enabling/disabling XR rendering canvas, used only on Web
     * @param options optional options to provide when creating a new render target
     * @returns a WebXR render target to which the session can render
     */
    WebXRSessionManager.prototype.getWebXRRenderTarget = function (onStateChangedObservable, options) {
        if (this._xrNavigator.xr.native) {
            return this._xrNavigator.xr.getWebXRRenderTarget(this.scene.getEngine());
        }
        else {
            return new WebXRManagedOutputCanvas(this.scene.getEngine(), this.scene.getEngine().getRenderingCanvas(), onStateChangedObservable, options);
        }
    };
    /**
     * @hidden
     * Converts the render layer of xrSession to a render target
     * @param session session to create render target for
     * @param scene scene the new render target should be created for
     */
    WebXRSessionManager._CreateRenderTargetTextureFromSession = function (session, scene, baseLayer) {
        if (!baseLayer) {
            throw "no layer";
        }
        // Create internal texture
        var internalTexture = new InternalTexture(scene.getEngine(), InternalTextureSource.Unknown, true);
        internalTexture.width = baseLayer.framebufferWidth;
        internalTexture.height = baseLayer.framebufferHeight;
        internalTexture._framebuffer = baseLayer.framebuffer;
        // Create render target texture from the internal texture
        var renderTargetTexture = new RenderTargetTexture("XR renderTargetTexture", { width: internalTexture.width, height: internalTexture.height }, scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);
        renderTargetTexture._texture = internalTexture;
        return renderTargetTexture;
    };
    /**
     * Disposes of the session manager
     */
    WebXRSessionManager.prototype.dispose = function () {
        this.onXRFrameObservable.clear();
        this.onXRSessionEnded.clear();
    };
    return WebXRSessionManager;
}());
export { WebXRSessionManager };
//# sourceMappingURL=webXRSessionManager.js.map
import { Nullable } from "../../types";
import { Observable } from "../../Misc/observable";
import { AbstractMesh } from "../../Meshes/abstractMesh";
import { Ray } from '../../Culling/ray';
import { Scene } from '../../scene';
import { WebVRController } from '../../Gamepads/Controllers/webVRController';
/**
 * Represents an XR input
 */
export declare class WebXRController {
    private scene;
    /** The underlying input source for the controller  */
    inputSource: XRInputSource;
    private parentContainer;
    /**
     * Represents the part of the controller that is held. This may not exist if the controller is the head mounted display itself, if thats the case only the pointer from the head will be availible
     */
    grip?: AbstractMesh;
    /**
     * Pointer which can be used to select objects or attach a visible laser to
     */
    pointer: AbstractMesh;
    private _gamepadMode;
    /**
     * If available, this is the gamepad object related to this controller.
     * Using this object it is possible to get click events and trackpad changes of the
     * webxr controller that is currently being used.
     */
    gamepadController?: WebVRController;
    /**
     * Event that fires when the controller is removed/disposed
     */
    onDisposeObservable: Observable<{}>;
    private _tmpMatrix;
    private _tmpQuaternion;
    private _tmpVector;
    /**
     * Creates the controller
     * @see https://doc.babylonjs.com/how_to/webxr
     * @param scene the scene which the controller should be associated to
     * @param inputSource the underlying input source for the controller
     * @param parentContainer parent that the controller meshes should be children of
     */
    constructor(scene: Scene, 
    /** The underlying input source for the controller  */
    inputSource: XRInputSource, parentContainer?: Nullable<AbstractMesh>);
    /**
     * Updates the controller pose based on the given XRFrame
     * @param xrFrame xr frame to update the pose with
     * @param referenceSpace reference space to use
     */
    updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace): void;
    /**
     * Gets a world space ray coming from the controller
     * @param result the resulting ray
     */
    getWorldPointerRayToRef(result: Ray): void;
    /**
     * Get the scene associated with this controller
     * @returns the scene object
     */
    getScene(): Scene;
    /**
     * Disposes of the object
     */
    dispose(): void;
}

import { NodeMaterialBlock } from '../../nodeMaterialBlock';
import { NodeMaterialBuildState } from '../../nodeMaterialBuildState';
import { NodeMaterialConnectionPoint } from '../../nodeMaterialBlockConnectionPoint';
import { BaseTexture } from '../../../Textures/baseTexture';
import { AbstractMesh } from '../../../../Meshes/abstractMesh';
import { NodeMaterial, NodeMaterialDefines } from '../../nodeMaterial';
import { Effect } from '../../../effect';
import { Mesh } from '../../../../Meshes/mesh';
import { Nullable } from '../../../../types';
import { Scene } from '../../../../scene';
import "../../../../Shaders/ShadersInclude/reflectionFunction";
/**
 * Block used to read a reflection texture from a sampler
 */
export declare class ReflectionTextureBlock extends NodeMaterialBlock {
    private _define3DName;
    private _defineCubicName;
    private _defineExplicitName;
    private _defineProjectionName;
    private _defineLocalCubicName;
    private _defineSphericalName;
    private _definePlanarName;
    private _defineEquirectangularName;
    private _defineMirroredEquirectangularFixedName;
    private _defineEquirectangularFixedName;
    private _defineSkyboxName;
    private _cubeSamplerName;
    private _2DSamplerName;
    private _positionUVWName;
    private _directionWName;
    private _reflectionCoordsName;
    private _reflection2DCoordsName;
    private _reflectionColorName;
    private _reflectionMatrixName;
    /**
     * Gets or sets the texture associated with the node
     */
    texture: Nullable<BaseTexture>;
    /**
     * Create a new TextureBlock
     * @param name defines the block name
     */
    constructor(name: string);
    /**
     * Gets the current class name
     * @returns the class name
     */
    getClassName(): string;
    /**
     * Gets the world position input component
     */
    readonly position: NodeMaterialConnectionPoint;
    /**
     * Gets the world position input component
     */
    readonly worldPosition: NodeMaterialConnectionPoint;
    /**
     * Gets the world normal input component
     */
    readonly worldNormal: NodeMaterialConnectionPoint;
    /**
     * Gets the world input component
     */
    readonly world: NodeMaterialConnectionPoint;
    /**
    * Gets the camera (or eye) position component
    */
    readonly cameraPosition: NodeMaterialConnectionPoint;
    /**
     * Gets the view input component
     */
    readonly view: NodeMaterialConnectionPoint;
    /**
     * Gets the rgb output component
     */
    readonly rgb: NodeMaterialConnectionPoint;
    /**
     * Gets the r output component
     */
    readonly r: NodeMaterialConnectionPoint;
    /**
     * Gets the g output component
     */
    readonly g: NodeMaterialConnectionPoint;
    /**
     * Gets the b output component
     */
    readonly b: NodeMaterialConnectionPoint;
    autoConfigure(material: NodeMaterial): void;
    prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
    isReady(): boolean;
    bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
    private _injectVertexCode;
    private _writeOutput;
    protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
    protected _dumpPropertiesCode(): string;
    serialize(): any;
    _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
}
